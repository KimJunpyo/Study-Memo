# EventLoop

Created: 2025년 6월 9일 오후 8:55
Tags: JS
Date: 2025년 6월 9일

## JavaScript Engine은 콜스택을 단 하나만 갖는다.

전역 실행 컨텍스트와 그 내부의 여러 실행 컨텍스트들이 존재하더라도, 가장 상단에 있는 현재 실행중인 실행 컨텍스트만이 JavaScript Engine이 실행중인 함수이다.

즉, JavaScript Engine은 한번에 하나의 함수만 실행할 수 있다.

따라서, JavaScript Engine은 싱글 스레드이다.

### 블로킹

싱글 스레드의 특성으로 인해 특정 함수나 태스크가 실행되는 동안 다른 태스트를 수행할 수 없어서, 실행 흐름이 일시적으로 멈추거나 지연되는 현상

### 동기

현재 실행중인 태스크가 종료되기 전까지 다음 태스크들이 대기하는 것

- 항상 순서대로 태스크가 실행된다는 장점이 있으나, 앞의 태스크가 종료되기 전까지 블로킹이 발생하는 단점이 있다.

### 비동기

현재 실행중인 태스크가 있음에도 곧바로 다음 태스크를 실행시키는 것

- 바로 함수가 실행되어 블로킹이 발생하지 않아 전체적인 태스크의 실행 및 종료 시간이 단축되지만, 순서가 보장되지 않는 단점이 있다.
- 대표적인 비동기 함수
  - setTimeout
  - setInterval
  - HTTP 통신
  - 이벤트 핸들러

JavaScript 엔진은 크게 힙 영역과 콜 스택 영역으로 나뉜다.

## 힙

객체가 저장되는 메모리 공간

- 런타임 시에(코드가 평가되고 실행 컨텍스트에 객체가 선언될 때) 동적으로 메모리를 할당하는 공간

JavaScript Engine은 코드의 평가와 실행만을 담당하며, 비동기 처리는 브라우저나 Node.js가 태스크 큐, 이벤트 루프를 이용하여 담당한다.

### 태스크 큐

비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역

### 마이크로태스크 큐

비동기 작업 중에서도 Promise.then, catch, finally, process.nextTick 등 특정 작업에서 반환된 콜백을 보관하는 영역

- 태스크 큐보다 우선 순위가 높아, 이벤트 루프가 먼저 해당 큐의 모든 태스크를 비운다.

## 이벤트 루프

콜 스택에 현재 실행중인 실행 컨텍스트가 있는지, 태스크 큐(마이크로태스크 큐)에 대기중인 함수가 있는지 반복적으로 확인하고 콜 스택이 비어있을 때, 순차적으로 태스크 큐(마이크로태스크 큐)에 대기하는 함수들을 콜 스택으로 이동시키는 매커니즘

- 마이크로태스크 큐에 있는 태스크들을 먼저 전부 비워낸 뒤, 태스크 큐를 비운다.
- 태스크 큐(마이크로태스크 큐)에 대기하던 함수들은 이동됨과 동시에 실행된다.

```jsx
const x = () => console.log("x");
const y = () => console.log("y");

setTimeout(x, 0);
y();
console.log("1");
console.log("2");

// 결과: y, 1, 2, x
```

1. 코드가 평가되어 전역 실행 컨텍스트에 선언 및 저장
2. 전역 실행 컨텍스트 실행 후, setTimeout 함수 동작
3. setTimeout 콜백 함수인 x는 호출 스케줄링을 하고 콜 스택에서 pop
4. 두가지 작업이 병렬로 이뤄짐

   4-1. 호출 스케줄링된 콜백 함수의 타이머가 종료되면, Node.js가 태스크 큐에 push하고 대기

   4-2. y함수 실행

5. console.log() 코드들이 순서대로 실행(이벤트 루프는 실행 컨텍스트가 비어야만 태스크 큐에 있는 함수를 콜 스택에 옮기기 때문에 대기됨)
6. 이후 더 이상 실행할 동기 함수가 존재하지 않아 전역 실행 컨텍스트 종료
7. 이때, 태스크 큐에 있던 함수를 콜 스택으로 옮기고 곧바로 실행

이러한 코드의 단점은, “전역 실행 컨텍스트가 종료될 때 까지 대기” 라는 점이다.

```jsx
const x = (value) => console.log("x", value);
const y = () => console.log("y");

const p = new Promise((resolve, reject) => {
  console.log("1");
  resolve("success");
  console.log("2");
});

p.then(x);
y();
console.log("7");
```

1. 코드의 평가 이후 전역 실행 컨텍스트 실행 및 new Promise 생성자 함수가 실행됨
2. 생성자 함수의 내부에서 console.log(”1”);이 동작하고, Promise의 성공 결과값에 “success”를 넘기며, console.log(”2”);가 동작됨
3. 콜백 함수가 종료되고, p.then 함수의 콜백 함수인 x는 Promise의 result가 결정되어있기 때문에 곧바로 마이크로태스크 큐에 저장
4. y 함수, console.log 함수가 동작된 후, 전역 실행 컨텍스트가 종료됨
5. 이 때, 마이크로태스크 큐의 x 콜백 함수가 실행
