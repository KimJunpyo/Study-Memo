# Closure

Created: 2025년 6월 2일 오후 9:46

## 클로저

자신이 선언된 환경의 변수를 기억하고, 그 환경에 접근할 수 있는 현상

- 자바스크립트가 렉시컬 스코프를 따르기에 발생하는 현상이다.
- 외부 함수의 변수를 그 함수 실행이 끝난 뒤에도 접근할 수 있을 때, 그 내부 함수를 클로저 함수라고 부른다.
- 전역 스코프에 접근할 수 있는 현상도 렉시컬 환경에 의해 상위 스코프를 참조한다는 개념은 같지만, 함수 실행이 끝나지 않기 때문에 “클로저” 라고 하지 않는다.

```jsx
// 이해하기 쉬운 클로저의 예시
// code 1 - 엄밀히 말하면 클로저
// 하지만 일반적으로는 클로저라고 부르지 않음 
const x = 1;
const y = () => {
  const x = 10;
  const z = () => console.log(x);
  z();
};
y(); // 10

// code 2 - 클로저 아님
const x = 1;
const y = () => {
  const x = 10;
  z();
};
const z = () => console.log(x);
y(); // 1
```

## 함수 객체의 내부 슬롯 Environment

상위 스코프의 참조가 저장되는 슬롯

- 함수 코드가 평가될 때, 자신이 정의된 환경의 위치에 의해 결정된 상위 스코프를 참조한다. ⇒ 현재 실행중인 실행 컨텍스트의 렉시컬 환경을 참조한다.
- 함수가 실행될 때, 생성된 실행 컨텍스트의 외부 렉시컬 환경에 대한 참조에 등록되는 값이다.

## 클로저 예시 코드 1

```jsx
const x = () => {
	const a = 1;
	const y = () => {
		console.log(a);
	}
	
	return y;
}

const x2 = x();
x2(); // 1;
```

1. y 함수의 코드가 평가될 때, y 함수 객체의 Environment 내부 슬롯에 x 함수의 렉시컬 환경이 저장
2. x 함수의 반환값인 y 함수가 x2 함수에 저장
3. 이후 x2 함수가 실행되면, y 함수 객체의 Environment에 내장된 상위 스코프의 렉시컬 환경을 x2 함수의 실행 컨텍스트 내의 외부 렉시컬 환경에 대한 참조에 저장
4. 실행 컨텍스트가 실행되며 a 변수를 현재 스코프에서 찾고, 존재하지 않기 때문에 상위 스코프에서 찾게 됨(클로저)
5. 1이 출력됨

## 클로저 예시 코드 2

```jsx
const counter = ({ initialValue = 0 }) => {
  let a = initialValue;

  const increase = () => {
    a += 1;
    console.log(a);
  };

  const decrease = () => {
    a -= 1;
    console.log(a);
  };

  const reset = (resetValue = 0) => {
    a = resetValue;
    console.log(a);
  };

  const get = () => {
    console.log(a);
  };

  return { increase, decrease, reset, get };
};

const { increase, decrease, reset, get } = counter({ initialValue: 10 });
increase(); // 11;
reset(); // 0;
decrease(); // -1;
get(); // -1;
```

1. counter 함수의 코드가 평가될 때, increase, decrease, reset, get 등 내부에서 정의된 메소드들이 평가되며 counter를 상위 스코프로서 Environment 내장 슬롯에 저장됨
2. counter 함수가 반환하는 메소드들은 전부 같은 상위 스코프를 참조함
3. a 변수의 값을 변경하거나 출력할 때, 메소드들에 의해 변경된 결과가 반영됨
4. 이는 a 변수가 클로저 현상으로 인해 counter 함수의 실행문이 종료되어 실행 컨텍스트가 사라졌음에도 해당 렉시컬 환경은 내장 메소드들안에서 참조되고 있어 Garbage Collector에 의해 메모리 할당이 해제되지 않기 때문이다.

## 클로저 현상의 특성

1. counter 함수를 여러 파일에서 호출하여 사용할 경우, 호출될 때 마다 각각 독립적인 렉시컬 환경이 생성됨
2. counter 함수를 호출하고, 호출된 결과를 여러 파일에서 호출하여 사용할 경우, 호출될 때 생성된 렉시컬 환경을 참조하고 있기 때문에 값이 공유됨(싱글톤 패턴)

### 캡슐화

OOP에서의 캡슐화: 객체의 내부 상태와 행위를 하나로 묶고, 외부에서 직접 상태를 변경하지 못하게 하며, 오직 메소드를 통해서만 상태를 제어할 수 있도록 하는 원칙

내부의 상태값을 직접적으로 수정할 수 없고 제공되는 메소드를 이용해서 수정할 수 있는 특징

- counter 함수의 내부 상태값을 직접적으로 수정할 수 없고 제공된 메소드를 이용해야만 값을 수정할 수 있다.

### 정보 은닉

내부 상태값을 직접 수정하거나 확인할 수 없고 접근할 수 없도록 하는 특성

- counter 함수는 내부 상태값인 a 변수를 직접 접근할 수 있는 방법이 없고, a 변수의 값 또한 직접적으로 수정할 수 없다.
- 그러나 엄밀히 말하면, “정보 은닉”은 보장되진 않는다.
    - 클로저 현상을 이용해 캡슐화를 구현한 함수의 내부 상태값은 정상적인 방법으로는 접근할 수 없다.
    - 그러나 디버깅 도구, 특정 해킹 기법등을 이용하여 내부 값을 확인할 수 있다.
    - 함수 자체를 toString()으로 구현하여 내부 구현을 확인하거나 일부 JavaScript 엔진에서는 엔진 내의 내부 슬롯을 접근하는 등의 비표준적 방식들로 값이 노출될 수 있다.
    - 결론: 실무에선 충분히 안정적이지만, 보안적으로 100% 안전한 정보 은닉은 아니다. 그러나 외부에서 직접적으로 내부 상태에 접근할 수 없으므로 실질적인 정보 은닉이 구현된다.
- ES2022 이후로 클래스의 #private 필드가 지원되어 “완벽한 정보 은닉”이 가능해짐

## 싱글톤 패턴

어떤 클래스(함수)로부터 단 하나의 인스턴스(객체)만 생성되도록 보장하고 그 인스턴스(객체)를 어디서든 접근할 수 있도록 하는 디자인 패턴

- 프로그램내에서 단 하나의 객체만 존재
- 전역 상태 관리, 설정 등을 위한 패턴으로 사용됨